# Controlling Execution Flow

The instruction pointer ```EIP``` determines which instruction is going to be
executed next. We cannot modify directly the instruction pointer however, there
are some instructions that can alter it in some specific conditions.

You can use instructions that modify the ```EIP``` register unconditionally
(*unconditional branches*) or based on a condition (*conditional branches*).

## Unconditional branches

There are three types of unconditional branches, *jumps*, *calls* and
*interrupts*.

* *Jumps* are used to go to a specific memory address declared as a label, such
  as ```loop:```, ```end:``` etc; when the processor encounters a jump the
  instruction pointer is changed to the address specified by the jump.

* *Calls* are similar to jump instructions but they remember where they jumped
  from and can return there. Calls are used to implement functions.

* *Interrupts* are used to signal events happening at the hardware level. When
  an interrupt is made the control of the processor is transferred to another
  program.


#### *Jumps*


#### *Calls*


#### *Interrupts*

There are two types: *software* and *hardware* interrupts.

* Hardware interrupts: are generated by hardware devices (these devices
  are outside of the processor, such as a hard disk). You can see the hardware
  interrupts received by a Linux system on ```/proc/interrupts```.

  Here is a sample file from my computer:

  ```
             CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7       
  0:         16          0          0          0          0          0          0          0  IR-IO-APIC-edge      timer
  1:          2          0          0          0          0          0          0          0  IR-IO-APIC-edge      i8042
  5:          0          0          0          0          0          0          0          0  IR-IO-APIC-edge      parport0
  8:          1          0          0          0          0          0          0          0  IR-IO-APIC-edge      rtc0
  9:          3          0          0          0          0          0          0          0  IR-IO-APIC-fasteoi   acpi
 12:          4          0          0          0          0          0          0          0  IR-IO-APIC-edge      i8042
 16:         33          0          0          0          0          0          0          0  IR-IO-APIC-fasteoi   ehci_hcd:usb1
 23:         37          0          0          0          0          0          0          0  IR-IO-APIC-fasteoi   ehci_hcd:usb2
 40:          0          0          0          0          0          0          0          0  DMAR_MSI-edge      dmar0
 41:          0          0          0          0          0          0          0          0  DMAR_MSI-edge      dmar1
 42:          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      PCIe PME
 43:          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      PCIe PME
 44:          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      PCIe PME
 45:      37323      31095          0      12515     468789     675352          0     307607  IR-PCI-MSI-edge      xhci_hcd
 46:          0          0          0          0          0          0          0          0  IR-PCI-MSI-edge      eth0
 47:      10510       8732          0       2732      26503      62080          0      14170  IR-PCI-MSI-edge      ahci
 48:         12          0          0          0          0          0          0          0  IR-PCI-MSI-edge      mei_me
 49:     328530          0          0          0          0          0          0          0  IR-PCI-MSI-edge      i915
 50:        492          0          0          0          0          0          0          0  IR-PCI-MSI-edge      snd_hda_intel
 51:        757          0          0          0          0          0          0          0  IR-PCI-MSI-edge      snd_hda_intel
NMI:          7          6          8          6          8          6          6          5   Non-maskable interrupts
LOC:      90265     113134     118445     114083     114226     146882      61643      77907   Local timer interrupts
SPU:          0          0          0          0          0          0          0          0   Spurious interrupts
PMI:          7          6          8          6          8          6          6          5   Performance monitoring interrupts
IWI:      11969      12279      11848      16697       1631       3601       3850       2180   IRQ work interrupts
RTR:          7          0          0          0          0          0          0          0   APIC ICR read retries
RES:      30822      16420      15986      13164      26054      20489       7436      12489   Rescheduling interrupts
CAL:        435        539        517        574        549        555        568        539   Function call interrupts
TLB:       4815       6519       5891       6532       3632       5132       4497       4378   TLB shootdowns
TRM:          0          0          0          0          0          0          0          0   Thermal event interrupts
THR:          0          0          0          0          0          0          0          0   Threshold APIC interrupts
MCE:          0          0          0          0          0          0          0          0   Machine check exceptions
MCP:         26         26         26         26         26         26         26         26   Machine check polls
ERR:          0
MIS:          0

  ```

* Software interrupts: are generated by programs and are provided by the
  operating system, you use the ```INT``` instruction.
  These interrupts provide functions within the operating system and the BIOS,
  Microsoft DOS used ```0x21``` as the software interrupt, ```0x10``` and
  ```0x16``` are for the BIOS interrupt call, and Linux uses ```0x80```.


When a program is called via interrupt, the caller is put on hold and the called
program takes the control. The instruction pointer is transferred to the called
program, which continues the execution until it completes, then the control
returns to the caller program using an interrupt return instruction (```IRET```
 or ```IRETD```).
